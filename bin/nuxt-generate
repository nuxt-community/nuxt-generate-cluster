#!/usr/bin/env node

// Show logs
process.env.DEBUG = process.env.DEBUG || 'nuxt:*'

const { defaults } = require('lodash')
const fs = require('fs')
const parseArgs = require('minimist')
const debug = require('debug')('nuxt:generate-master')

const { Nuxt, Builder } = require('nuxt')
const { Generator } = require('../')
const resolve = require('path').resolve
const store = require('data-store')('nuxt-generate-cluster')

const argv = parseArgs(process.argv.slice(2), {
  alias: {
    b: 'build',
    h: 'help',
    c: 'config-file',
    p: 'params',
    w: 'workers',
    wc: 'worker_concurrency',
    s: 'spa',
    u: 'universal'
  },
  boolean: ['b', 'h', 's', 'u'],
  string: ['c', 'p'],
  number: ['w', 'wc'],
  default: {
    c: 'nuxt.config.js'
  }
})

if (argv.help) {
  console.log(`
    Description
      Generate a static web application (server-rendered)
    Usage
      $ nuxt-generate <dir>
    Options
      -b, --build           Whether to (re-)build the nuxt project
      -c, --config-file     Path to Nuxt.js config file (default: nuxt.config.js)
      -h, --help            Displays this message
      -p, --params          Extra parameters which should be passed to routes method
                              (should be a JSON string or queryString)
      -w, --workers [NUM]   How many workers should be started
                              (default: # cpus)
      -wc [NUM],            How many routes should be sent to 
      --worker-concurrency [NUM]    a worker per iteration

      --spa               Launch in SPA mode
      --universal         Launch in Universal mode (default)
  `)
  process.exit(0)
}

const rootDir = resolve(argv._[0] || '.')
const nuxtConfigFile = resolve(rootDir, argv['config-file'])

var options = {}
if (fs.existsSync(nuxtConfigFile)) {
  options = require(nuxtConfigFile)
} else if (argv['config-file'] !== 'nuxt.config.js') {
  console.error(`> Could not load config file ${argv['config-file']}`)
  process.exit(1)
}
if (typeof options.rootDir !== 'string') {
  options.rootDir = rootDir
}
options.dev = false // Force production mode (no webpack middleware called)

// Nuxt Mode
options.mode = (argv['spa'] && 'spa') || (argv['universal'] && 'universal') || options.mode

const nuxt = new Nuxt(options)

let numWorkers = 0
if (argv['workers'] === true || 
    argv['workers'] === 0 || 
    (typeof argv['workers'] === 'undefined' && 
      (nuxt.options.generate.workers === 0 || typeof(nuxt.options.generate.workers) === 'undefined')
    )) {
  numWorkers = require('os').cpus().length
} else if(parseInt(argv['workers'])) {
  numWorkers = parseInt(argv['workers'])
} else {
  numWorkers = nuxt.options.generate.workers
}

if (numWorkers < 1) {
  numWorkers = 1
}


let workerConcurrency
if (parseInt(argv['worker_concurrency']) > 0 ) {
  workerConcurrency = parseInt(argv['worker_concurrency'])
} else if (parseInt(nuxt.options.generate.workerConcurrency)) {
  workerConcurrency = parseInt(nuxt.options.generate.workerConcurrency)
} else {
  workerConcurrency = 500
}

options.workerConcurrency = workerConcurrency


const storeTime = (key, time) => {
  timers[key] = time || Math.round(new Date().getTime()/1000)
  store.set(timers)
  store.save()
}

const timers = defaults({}, store.data || {}, {
  lastStarted: 0,
  lastBuilt: 0,
  lastFinished: 0
})

const cluster = require('cluster')
cluster.setupMaster({
  exec: __dirname + '/nuxt-generate-worker.js'
})

debug(`master process ${process.pid} is running`)

const start = process.hrtime()
const watchdog = {}
let routes

storeTime('lastStarted')

const builder = new Builder(nuxt)
const generator = new Generator(nuxt, builder)

generator.initiate({ build: argv['build'], init: argv['build'] })
.then(() => {
  if (!argv['build']) {
    // TODO: when too long ago show message but what is too long?
  } else {
    storeTime('lastBuilt')
  }

  let params
  if (argv['params']) {
    try {
      params = JSON.parse(argv['params'])
    } catch(e) {}

    if (!params) {
      params = require('querystring').parse(argv['params'])
    }

    if (!params) {
      debug('Could not parse params as JSON or queryString')
    }
  }

  params = defaults(params, timers)

  debug(`Creating routes`)
  return generator.initRoutes(params)
}).then((_routes) => {
  routes = _routes
  debug(`A total of ${routes.length} routes will be generated`)

  for (let i = 0; i < numWorkers; i++) {
    cluster.fork({ options: JSON.stringify(options) })
  }
})

// Initiate watchdog options when a new worker is started
cluster.on('fork', function (worker) {
  debug(`Worker ${worker.process.pid} started`);

  watchdog[worker.process.pid] = {
    start: process.hrtime(),
    duration: 0,
    signal: 0,
    code: 0,
    routes: 0,
    errors: []
  }
})

// Listener for when a worker sends a message
cluster.on('message', function(worker, msg) {
  if (msg.cmd) {
    if (msg.cmd === 'requestRoutes') {
      if (routes.length) {
        // Even the load between workers
        let workerConcurrency = options.generate.workerConcurrency
        if (routes.length < numWorkers * options.generate.workerConcurrency) {
          workerConcurrency = Math.ceil(routes.length / numWorkers)
        }

        let workerRoutes = routes.splice(0, workerConcurrency)

        if (workerRoutes.length) {
          debug(`Sending ${workerRoutes.length} routes to worker ${worker.process.pid}`)
          watchdog[worker.process.pid].routes += workerRoutes.length

          worker.send({ cmd: msg.cmd, routes: workerRoutes })
        } else {
          debug(`No more routes, exiting worker ${worker.process.pid}`)
          worker.disconnect()
        }
      } else {
        debug(`No more routes, exiting worker ${worker.process.pid}`)
        worker.disconnect()
      }
    } else if (msg.cmd === 'errors') {
      if (msg.errors.length) {
        Array.prototype.push.apply(watchdog[worker.process.pid].errors, msg.errors)
      }
    }
  }
})

// Listener for when a worker exists
cluster.on('exit', function(worker, code, signal) {
  let duration = process.hrtime(watchdog[worker.process.pid].start)
  watchdog[worker.process.pid].duration = Math.round((duration[0] * 1E9 + duration[1]) / 1E6)

  let message = `Worker ${worker.process.pid} exited`
  if (signal) {
    message += ` by signal ${signal}`

    watchdog[worker.process.pid].signal = signal
  } else if(code !== 0) {
    message += ` with error code ${code}`

    watchdog[worker.process.pid].code = code
  }
  debug(message)

  let allWorkersDead = true
  for (let pid in watchdog) {
    if (watchdog[pid].duration === 0) {
      allWorkersDead = false
      break
    }
  }

  if (allWorkersDead) {
    // print report
    let errors = []
    for (let pid in watchdog) {
      let workerMsg = `Worker ${pid} generated ${watchdog[pid].routes} routes in ${Math.round(watchdog[pid].duration/100)/10}s`
      if (watchdog[pid].errors.length) {
        workerMsg += ` with ${watchdog[pid].errors.length} errors`

        Array.prototype.push.apply(errors, watchdog[pid].errors)
      }
      debug(workerMsg)
    }

    generator.postGenerate()
    .then(() => {
      duration = process.hrtime(start)
      duration = Math.round((duration[0] * 1E9 + duration[1]) / 1E8)/10

      generator.printReport(duration, errors)

      storeTime('lastFinished')
      
      if (options.generate.finished && typeof options.generate.finished === 'function') {
        options.generate.finished({ 
          duration: duration, 
          errors: errors, 
          workerInfo: watchdog
        })
      }
    })
  }
})
